#!/usr/bin/python
import re
import sys
sys.path.append("lib")
sys.path.append("pytests")
import time
import getopt
import unittest
import os
import logger
from xunit import XUnitTestResult
from TestInput import TestInputParser, TestInputSingleton


def usage(err=None):
    if err:
        print "Error: %s\n" % err
        r = 1
    else:
        r = 0

    print """\
Syntax: testrunner [options]

Options:
 -c <file>        Config file name (located in the conf subdirectory)
 -i <file>        Path to .ini file containing server information
 -t <test>        Test name (multiple -t options add more tests)
 -n               NO-OP - emit test names, but don't actually run them
 -h               Show this help message

The config file can have a list of test names.

Examples:
  ./testrunner -i tmp/local.ini -t performance.perf.DiskDrainRate
  ./testrunner -i tmp/local.ini -t performance.perf.DiskDrainRate.test_9M
"""
    sys.exit(r)


def parse_args(argv):
    noop = False
    tests = []
    arg_i = None
    arg_p = None

    try:
        (opts, args) = getopt.getopt(argv[1:],
                                     'c:hi:np:t:v:', [])
        for o, a in opts:
            if o == "-h":
                usage()
            elif o == "-c":
                parse_runlist(tests, a)
            elif o == "-t":
                append_test(tests, a)
            elif o == "-i":
                arg_i = o + " " + a
            elif o == "-p":
                arg_p = o + " " + a
            elif o == "-n":
                noop = True

        if noop:
            print("\n".join(tests))
            exit(0)

        test_input = TestInputParser.get_test_input(argv)
        if not test_input.servers:
            usage("no servers specified")
        if not tests:
            usage("no tests specified")
        return tests, test_input, arg_i, arg_p

    except IndexError:
        usage()
    except getopt.GetoptError, err:
        usage(err)


def find_runlist(filename):
    if os.path.exists(filename):
        return file(filename)
    if os.path.exists("conf/" + filename):
        return file("conf/" + filename)
    return None


def parse_runlist(tests, filename):
    f = find_runlist(filename)
    if not f:
        usage("bad conf: " + filename)
    prefix = None
    for line in f:
        stripped = line.strip()
        if stripped.startswith("#") or len(stripped) <= 0:
            continue
        if stripped.endswith(":"):
            prefix = stripped.split(":")[0]
            continue
        name = stripped
        if line.startswith(" ") and prefix:
            name = prefix + "." + name
        prefix = ".".join(name.split(".")[0:-1])
        append_test(tests, name)


def append_test(tests, name):
    prefix = ".".join(name.split(".")[0:-1])
    if name.find('*') > 0:
        for t in unittest.TestLoader().loadTestsFromName(name.rstrip('.*')):
            tests.append(prefix + '.' + t._testMethodName)
    else:
        tests.append(name)

if __name__ == "__main__":
    str_time = time.strftime("%H:%M:%S", time.localtime()).replace(":", "-")
    names, test_input, arg_i, arg_p = parse_args(sys.argv)

    xunit = XUnitTestResult()

    tmp_folder = "tmp-{0}".format(str_time)
    os.makedirs(tmp_folder)
    #this only works on linux/mac
    os.environ["TEMP-FOLDER"] = os.getcwd() + "/" + tmp_folder
    print os.environ["TEMP-FOLDER"]

    for name in names:
        #let's create temporary folder for logs and xml results
        start_time = time.time()
        argument_split = [a.strip() for a in re.split("[,]?([^,=]+)=", name)[1:]]
        params = dict(zip(argument_split[::2], argument_split[1::2]))
        if params:
            log_name = name
        else:
            dotnames = name.split('.')
            log_name = dotnames[len(dotnames) - 1]

        logger.Logger.start_logger(log_name)
        name = name.split(",")[0]
        print("  ./testrunner {0} {1} -t {2}".format(arg_i or "", arg_p or "", name))

        TestInputSingleton.input = TestInputParser.get_test_input(sys.argv)
        TestInputSingleton.input.test_params.update(params)
        suite = unittest.TestLoader().loadTestsFromName(name)
        result = unittest.TextTestRunner(verbosity=2).run(suite)
        logger.Logger.stop_logger()
        time_taken = time.time() - start_time
        if result.failures or result.errors:
            for failure in result.failures:
                test_case, failure_string = failure
                xunit.add_test(name=name, status='fail', time=time_taken,
                               errorType='membase.error', errorMessage=failure_string)
                break
            for error in result.errors:
                test_case, error_string = error
                xunit.add_test(name=name, status='fail', time=time_taken,
                               errorType='membase.error', errorMessage=error_string)
                break
        else:
            xunit.add_test(name=name, time=time_taken)
        xunit.write("{0}/report-{1}.xml".format(tmp_folder, str_time))
        xunit.print_summary()
        print "logs and results are available under {0}".format(tmp_folder)
